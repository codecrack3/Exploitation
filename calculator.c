/*

sott = targ - ( (unsigned int)pow(2,32)-(last-targ-1) );

After this sott = last!

*/


#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <string.h>
#include <math.h>
 
#define PBLE "!#$%&()*+,-.1/23456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_abcdefghijkllmnopqrstuvwxyz{|}" //PBLE is from smaller to bigger

char minus[4];

int cont_0 = 88, cont_1 = 88, cont_2 = 88, cont_3 = 88 , cont_tent = 88;

int recalc_minus(void) //this doesn't count ALL the choices, [TODO]
{ 
 if(cont_3>0)
    {cont_3--; return 1;}
 else 
     {
      if(cont_2>0)
         {cont_2--; return 1; }
      else
          {
           if(cont_1>0)
              {cont_1--; return 1; }
           else
               {
                if(cont_0>0)
                  {cont_0--; return 1; }
                else
                  {
                   if (cont_tent>0)
                       {
                        cont_tent--;
                        cont_0 = cont_tent;
                        cont_1 = cont_tent;
                        cont_2 = cont_tent;
                        cont_3 = cont_tent;
                        return 2;                         
                       }
                   else
                       return -1;
                  }
               }
          }
     }
}



int main(int argc , char* argv[])
{

unsigned int targ , last , diff;
unsigned int sign , sign_temp , sign_old_temp;

int t=0 , end=0 , z;
unsigned int result;
char history[20][4];

char mem[65];
char shellcode[500];
char* path;
FILE *f1;

memset(&mem,0,sizeof(mem));
memset(&history,0,sizeof(history));
strcpy(mem,PBLE);

/*if(argc != 4)
  {
   printf("Usage: <%s> <esp start> <esp end> <path to shellcode>", argv[0]);
  }
*/

targ = strtoul(argv[2],NULL,0); //if 0, the base used is determined by the format of the sequence. 0x = hex 
last = strtoul(argv[3],NULL,0);


sign =( (unsigned int)pow(2,32)-(last-targ-1) ); //now I know how many I have to subtract from target to reach last
sign_temp = sign;

printf("To reach %p from %p you have to subtract %p\n", last,targ,sign);
puts("Now trying to guess the correct ascii to subtract\n");
result = targ;

unsigned int sign_next_temp;
char *cursor;
unsigned int val=0;

do
  { 
    minus[0] = mem[cont_3];  //At the beginning minus is 0x7A7A7A7A, the biggest ascii pass to subtract from the target.
    minus[1] = mem[cont_2];
    minus[2] = mem[cont_1];
    minus[3] = mem[cont_0]; 
    val=0;
    cursor = &val; //This chunk of code copy very rawly byte to byte a string into a unsigned int varaible, so now in val I have 7A7A7A7A ( in general minus's content )     
    memcpy(cursor,minus,1);
    cursor++;
    memcpy(cursor,minus+1,1);
    cursor++;
    memcpy(cursor,minus+2,1);
    cursor++;
    memcpy(cursor,minus+3,1);
    
    //printf("val is %p", val); //correct!
    printf("sign_temp is %p", sign_temp);
    sign_temp= sign_temp - val; 
    printf(" now subtracting val %p and obtaining %p", val , sign_temp);
    sign_next_temp = sign_temp - val;
    printf("the sign_next is %p\n", sign_next_temp);

    //printf("sign is %p", sign_temp);
    if( sign_temp!=0 && ( sign_next_temp > sign_temp ) )
      {
       sign_temp+= val; // Switch back the sign_temp
       printf("due to %p > %p sign_temp is recalc to %p, and result is invariant\n\n\n" ,sign_next_temp, sign_temp, sign_temp);
       z = recalc_minus();
       if( z == -1 )
           { 
             puts("No sequence found, sorry...\n");
             exit(0);
           }   
        if( z == 2 ) // Start from the beginning problem with a 'minus' smaller than previous attemp
          {
           puts("Now resetting\n");
           sign_temp = sign;
           result = targ; 
           memset(&history , 0 , sizeof(history));
           t=0;
          }
      }
    else
    	{
        printf("I correctly subtract something to sign so i can sub %s ( %p )  from %p\n",minus, val , result);
        result = result - val;
        printf("Now result is %p , we have other sub to arrive at %p\n\n\n", result , last);

    	history[t][0] = minus [0];
        history[t][1] = minus [1];
        history[t][2] = minus [2];
        history[t][3] = minus [3];
        t++; 
    
        if( result == last ) //If I arrived here so I find the correct sequence.
      	  { 
           printf("FIND THE CORRECT ASCII SEQUENCE TO REACH %p!\n", last);
           puts("--------------------------------\n");
           int i,j;
           for(i=0;i<20;i++)
              {
               for(j=0;j<4;j++)
                   printf("%p",history[i][j]);
               printf("\n");
              }
           end = 1;
          }       
        }
    }while(!end);



//printf("sott is %p\n" , sott);
//sott = sott - (unsigned int)"AAAA";
//printf("now sott is %p\n" , sott);
//printf("%p %p %p %p", t[3],t[2],t[2],t[0]);
//printf("Difference is %p\n",diff);

//strcpy(path, argv[4]);
//f1 = open(path,"r");
}
